(ns stubb-app.sitemap-analyzer-test
  (:require [clojure.test :as t]
            [clojure.edn :as edn]
            [clojure.string :as str]
            [clojure.java.io :as io]))

;(def processed-sitemap-url "/Users/rpierce/Workspaces/Clojure_Workspace/stubb_app/sitemap_results/csi-rent/5-4-2018")
(def processed-sitemap-root (atom nil)) ;holds the root node for the processed-sitemap generated by sitemap-analyzer.clj
(def processed-sitemap (atom nil)) ; holds the actual processed-sitemap data (edn)
(def summary-data (atom {:tests-run 0 :failures {:no-index 0 :non-200 0}})) ; holds summary statistics
(def failing-urls (atom {:no-index #{} :non-200 #{}}))  ; holds data on failing urls

(defn read-sitemap-results
  "edn reader function to read in the processed sitemap results"
  [file]
  (with-open [r (java.io.PushbackReader. (io/reader file))]
    (binding [*read-eval* false]
      (edn/read r))))

(defn load-processed-sitemap
  "Takes in a path to a processed sitemap and then reads the .edn files and loads them into memory.
  TODO: This may not be the best way to do this. Can get by with some proper let statements and not need the atoms."
  [path-to-sitemap]
  (let [sitemap-root (io/file path-to-sitemap)
        edn-files (filter (fn [f]
                            (let [{is-file? :file 
                                   file-name :name} (bean f)]
                              (and is-file?
                                   (str/ends-with? file-name ".edn"))))
                          (file-seq sitemap-root))
        sitemap-results (map read-sitemap-results edn-files)]
    (reset! processed-sitemap-root sitemap-root)
    (reset! processed-sitemap sitemap-results)))

(defn report-builder
  [test-result]
  (t/with-test-out
    (let [{:keys [type expected actual message]} test-result
          results-count (first t/*testing-contexts*)]
      (println (str "the results count is: " results-count)))))

(defn process-url-test
  "Actually updates the submap statistics."
  [url-test]
  (let [{:keys [url status error robots-meta]} url-test
        num-tests-run (get @summary-data :tests-run)
        num-no-index-failures (get-in @summary-data [:failures :no-index])
        num-non-200-failures (get-in @summary-data [:failures :non-200])
        failing-non-200-urls (get @failing-urls :non-200)
        failing-no-index-urls (get @failing-urls :no-index)]
    (swap! summary-data assoc :tests-run (inc num-tests-run))
    (if (not= 200 status)
      (do
        (swap! summary-data assoc-in [:failures :non-200] (inc num-non-200-failures))
        (swap! failing-urls assoc :non-200 (conj failing-non-200-urls url)))
      (if (contains? robots-meta "noindex")
        (do
          (swap! summary-data assoc-in [:failures :no-index] (inc num-no-index-failures))
          (swap! failing-urls assoc :no-index (conj failing-no-index-urls url)))))))

(defn process-submap
  "Processes a submap (results from an individual xml file) of the sitemap. Responsible for
  updating statistics on failures as well as collecting lists of failing urls by type."
  [submap]
  (let [{:keys [meta results]} submap]
    ;do something with the meta data here
    (doall (map process-url-test results))
    (println "Finished processing submap <get-name-from-meta>")))

(defn write-failing-non-200-urls
  "Function that writes failing urls that returned a non-200 status into 
  a file passed in as a param by persist-analysis-data func"
  [out-file]
  (let [non-200-data {:failing-non-200-urls (get @failing-urls :non-200)}]
    (with-open [w (io/writer out-file)]
      (binding [*out* w]
        (pr non-200-data)))))

(defn write-failing-no-index-urls
  "Function that writes failing urls that returned a no-index robots-meta tag  
  into a file passed in as a param by persist-analysis-data func"
  [out-file]
  (let [no-index-data {:failing-no-index-urls (get @failing-urls :no-index)}]
    (with-open [w (io/writer out-file)]
      (binding [*out* w]
        (pr no-index-data)))))

(defn write-summary-stats
  "Function that writes the summary statistics into a file passed in as a param
  by the persist-analysis-data func."
  [out-file]
  (let [no-index-failures (get-in @summary-data [:failures :no-index])
        non-200-failures (get-in @summary-data [:failures :non-200])
        summary-data {:tests-run (get @summary-data :tests-run)
                      :test-failures (+ no-index-failures non-200-failures)
                      :failures-by-type {:no-index no-index-failures
                                         :non-200 non-200-failures}}]
    (with-open [w (io/writer out-file)]
      (binding [*out* w]
        (pr summary-data)))))

(defn persist-analysis-data
  "Writes the analysis results into a new directory in sitemap-root directory 
  (<path-to-sitemap> param for analyze-sitemap func). "
  []
  (let [analysis-directory (io/file @processed-sitemap-root "analysis")
        failing-url-directory (io/file analysis-directory "failing_urls")
        _ (io/make-parents failing-url-directory "no-index") ; <- is this necessary? It seems so
        summary-file (io/file analysis-directory "summary.edn")
        no-index-file (io/file failing-url-directory "no-index-failures.edn")
        non-200-file (io/file failing-url-directory "non-200-failures.edn")]
    (write-summary-stats summary-file)
    (write-failing-no-index-urls no-index-file)
    (write-failing-non-200-urls non-200-file)))

(defn analyze-sitemap
  "Takes a path to a processed sitemap (processed by sitemap-analyzer.clj),
  and analyzes the results. Produces a new directory relative to <path-to-sitemap>
  with analysis results"
  [path-to-sitemap]
  (load-processed-sitemap path-to-sitemap)
  (doall (map process-submap @processed-sitemap))
  (persist-analysis-data))
